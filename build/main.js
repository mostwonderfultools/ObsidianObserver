/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __markAsModule = (target) => __defProp(target, "__esModule", { value: true });
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[Object.keys(fn)[0]])(fn = 0)), res;
};
var __export = (target, all) => {
  __markAsModule(target);
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __reExport = (target, module2, desc) => {
  if (module2 && typeof module2 === "object" || typeof module2 === "function") {
    for (let key of __getOwnPropNames(module2))
      if (!__hasOwnProp.call(target, key) && key !== "default")
        __defProp(target, key, { get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable });
  }
  return target;
};
var __toModule = (module2) => {
  return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, "default", module2 && module2.__esModule && "default" in module2 ? { get: () => module2.default, enumerable: true } : { value: module2, enumerable: true })), module2);
};

// src/utils.ts
var utils_exports = {};
__export(utils_exports, {
  generateBase32Guid: () => generateBase32Guid
});
function generateBase32Guid() {
  const uuid = "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, function(c) {
    const r = Math.random() * 16 | 0;
    const v = c === "x" ? r : r & 3 | 8;
    return v.toString(16);
  });
  return uuidToBase32(uuid);
}
function uuidToBase32(uuid) {
  const cleanUuid = uuid.replace(/-/g, "").toLowerCase();
  let binary = "";
  for (let i = 0; i < cleanUuid.length; i++) {
    const hex = parseInt(cleanUuid[i], 16);
    binary += hex.toString(2).padStart(4, "0");
  }
  const base32Chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567";
  let base32 = "";
  for (let i = 0; i < binary.length; i += 5) {
    const chunk = binary.substr(i, 5).padEnd(5, "0");
    const decimal = parseInt(chunk, 2);
    base32 += base32Chars[decimal];
  }
  return base32.substring(0, 26);
}
var init_utils = __esm({
  "src/utils.ts"() {
  }
});

// src/main.ts
__export(exports, {
  DEFAULT_SETTINGS: () => DEFAULT_SETTINGS,
  default: () => ObsidianObserverPlugin
});
var import_obsidian2 = __toModule(require("obsidian"));

// src/logger.ts
var EventLogger = class {
  constructor(app, config, pluginVersion = "unknown") {
    this.logBuffer = [];
    this.maxBufferSize = 3;
    this.app = app;
    this.config = config;
    this.pluginVersion = pluginVersion;
  }
  log(message, ...args) {
    if (this.config.enableConsoleLog) {
      console.log(message, ...args);
    }
  }
  getPluginVersion() {
    return this.pluginVersion;
  }
  getHostname() {
    try {
      if (typeof require !== "undefined") {
        try {
          const os = require("os");
          if (os && typeof os.hostname === "function") {
            const hostname = os.hostname();
            this.log("[ObsidianObserver] os.hostname() result:", hostname);
            if (hostname && hostname.trim() && hostname !== "localhost" && hostname !== "127.0.0.1" && hostname !== "::1") {
              return hostname;
            }
          }
        } catch (osError) {
          this.log("[ObsidianObserver] os module not available or error:", osError);
        }
      }
      if (typeof process !== "undefined" && process.env) {
        if (process.env.HOSTNAME && process.env.HOSTNAME !== "localhost") {
          return process.env.HOSTNAME;
        }
        if (process.env.COMPUTERNAME && process.env.COMPUTERNAME !== "localhost") {
          return process.env.COMPUTERNAME;
        }
        if (process.env.USERDOMAIN && process.env.USERDOMAIN !== "localhost") {
          return process.env.USERDOMAIN;
        }
        if (process.env.USER && process.env.USER !== "localhost") {
          return process.env.USER;
        }
      }
      let machineId = "obsidian";
      if (this.app && this.app.vault) {
        try {
          const vaultName = this.app.vault.getName();
          if (vaultName && vaultName.trim() && vaultName !== "vault") {
            const cleanName = vaultName.replace(/[^a-zA-Z0-9]/g, "").toLowerCase();
            if (cleanName.length > 0) {
              machineId = cleanName;
            }
          }
        } catch (vaultError) {
          this.log("[ObsidianObserver] Could not get vault name:", vaultError);
        }
      }
      let identifier = machineId;
      if (typeof navigator !== "undefined" && navigator.platform) {
        if (navigator.platform.includes("Mac")) {
          identifier += "-mac";
        } else if (navigator.platform.includes("Win")) {
          identifier += "-win";
        } else if (navigator.platform.includes("Linux")) {
          identifier += "-linux";
        }
      }
      const sessionId = Math.random().toString(36).substring(2, 6);
      const finalId = `${identifier}-${sessionId}`;
      this.log("[ObsidianObserver] Generated machine identifier:", finalId);
      return finalId;
    } catch (error) {
      console.warn("[ObsidianObserver] Could not determine hostname:", error);
      const fallbackId = Math.random().toString(36).substring(2, 8);
      return `fallback-${fallbackId}`;
    }
  }
  getConfig() {
    return this.config;
  }
  updateConfig(newConfig) {
    this.config = newConfig;
    this.log("[ObsidianObserver] Logger configuration updated:", newConfig);
  }
  async ensureEventsDirectoryExists() {
    try {
      const eventsDir = `${this.config.eventsFolder}/events`;
      const dirExists = this.app.vault.getAbstractFileByPath(eventsDir);
      if (!dirExists) {
        try {
          await this.app.vault.createFolder(eventsDir);
          this.log(`[ObsidianObserver] Created events directory: ${eventsDir}`);
          this.app.workspace.trigger("file-explorer:refresh");
        } catch (createError) {
          if (createError.message && createError.message.includes("already exists")) {
            this.log(`[ObsidianObserver] Events directory already exists: ${eventsDir}`);
          } else {
            throw createError;
          }
        }
      } else {
        this.log(`[ObsidianObserver] Events directory already exists: ${eventsDir}`);
      }
    } catch (error) {
      console.error("[ObsidianObserver] Error ensuring events directory exists:", error);
    }
  }
  async logEvent(eventLog) {
    try {
      this.logBuffer.push(eventLog);
      if (this.logBuffer.length >= this.maxBufferSize) {
        await this.flushBuffer();
      }
      if (this.config.enableConsoleLog) {
        this.log(`[ObsidianObserver] ${eventLog.eventType}: ${eventLog.filePath}`);
      }
    } catch (error) {
      console.error("[ObsidianObserver] Error logging event:", error);
    }
  }
  async flushBuffer() {
    if (this.logBuffer.length === 0)
      return;
    try {
      for (const eventLog of this.logBuffer) {
        await this.createEventNote(eventLog);
      }
      this.log(`[ObsidianObserver] Buffer flushed: ${this.logBuffer.length} event notes created`);
      this.logBuffer = [];
    } catch (error) {
      console.error("[ObsidianObserver] Error flushing log buffer:", error);
    }
  }
  async createEventNote(eventLog) {
    var _a, _b, _c, _d, _e;
    try {
      const eventsDir = `${this.config.eventsFolder}/events`;
      const fileName = `${eventLog.guid}.md`;
      const filePath = `${eventsDir}/${fileName}`;
      const utcDate = new Date(eventLog.timestamp);
      const localDate = new Date(utcDate.getTime() - utcDate.getTimezoneOffset() * 6e4);
      const timezone = Intl.DateTimeFormat().resolvedOptions().timeZone;
      const frontmatter = {
        OOEvent_GUID: eventLog.guid,
        OOEvent_Timestamp: eventLog.timestamp,
        OOEvent_LocalTimestamp: localDate.toISOString(),
        OOEvent_Timezone: timezone,
        OOEvent_Type: eventLog.eventType,
        OOEvent_FilePath: eventLog.filePath,
        OOEvent_FileName: eventLog.fileName,
        OOEvent_VaultName: eventLog.vaultName,
        OOEvent_Hostname: eventLog.hostname,
        OOEvent_LastModified: ((_a = eventLog.metadata) == null ? void 0 : _a.lastModified) || "",
        OOEvent_Created: new Date().toISOString(),
        OOEvent_OldPath: (_b = eventLog.metadata) == null ? void 0 : _b.oldPath,
        OOEvent_NewPath: (_c = eventLog.metadata) == null ? void 0 : _c.newPath,
        OOEvent_SourcePath: (_d = eventLog.metadata) == null ? void 0 : _d.sourcePath,
        OOEvent_TargetPath: (_e = eventLog.metadata) == null ? void 0 : _e.targetPath,
        OOEvent_PluginVersion: this.getPluginVersion()
      };
      const noteContent = this.createNoteContent(frontmatter, eventLog);
      const existingFile = this.app.vault.getAbstractFileByPath(filePath);
      if (existingFile) {
        this.log(`[ObsidianObserver] Event note already exists: ${filePath}`);
        return;
      }
      await this.app.vault.create(filePath, noteContent);
      this.log(`[ObsidianObserver] Created event note: ${filePath}`);
      this.app.workspace.trigger("file-explorer:refresh");
    } catch (error) {
      console.error(`[ObsidianObserver] Error creating event note:`, error);
    }
  }
  createNoteContent(frontmatter, eventLog) {
    let frontmatterFields = `---
aliases: [${eventLog.eventType.toUpperCase()} Event, ${eventLog.fileName}]
tags: [obsidian-explorer, event, ${eventLog.eventType}]
type: obsidian-event
OOEvent_GUID: ${frontmatter.OOEvent_GUID}
OOEvent_Timestamp: ${frontmatter.OOEvent_Timestamp}
OOEvent_LocalTimestamp: ${frontmatter.OOEvent_LocalTimestamp}
OOEvent_Timezone: ${frontmatter.OOEvent_Timezone}
OOEvent_Type: ${frontmatter.OOEvent_Type}
OOEvent_FilePath: ${frontmatter.OOEvent_FilePath}
OOEvent_FileName: ${frontmatter.OOEvent_FileName}
OOEvent_VaultName: ${frontmatter.OOEvent_VaultName}
OOEvent_Hostname: ${frontmatter.OOEvent_Hostname}
OOEvent_LastModified: ${frontmatter.OOEvent_LastModified}
OOEvent_Created: ${frontmatter.OOEvent_Created}
OOEvent_PluginVersion: ${frontmatter.OOEvent_PluginVersion}`;
    if (frontmatter.OOEvent_OldPath) {
      frontmatterFields += `
OOEvent_OldPath: ${frontmatter.OOEvent_OldPath}`;
    }
    if (frontmatter.OOEvent_NewPath) {
      frontmatterFields += `
OOEvent_NewPath: ${frontmatter.OOEvent_NewPath}`;
    }
    if (frontmatter.OOEvent_SourcePath) {
      frontmatterFields += `
OOEvent_SourcePath: ${frontmatter.OOEvent_SourcePath}`;
    }
    if (frontmatter.OOEvent_TargetPath) {
      frontmatterFields += `
OOEvent_TargetPath: ${frontmatter.OOEvent_TargetPath}`;
    }
    frontmatterFields += `
---

`;
    let noteContent = frontmatterFields;
    if (eventLog.fileName && eventLog.fileName.trim() !== "") {
      noteContent += `[[${eventLog.fileName}]]`;
    } else {
      noteContent += `# ${eventLog.eventType.toUpperCase()} Event

This event was logged at ${new Date(eventLog.timestamp).toLocaleString()}.`;
    }
    return noteContent;
  }
  async createSummaryNote() {
    try {
      const summaryPath = `${this.config.eventsFolder}/events/_summary.md`;
      const summaryContent = `---
aliases: [ObsidianObserver Events Summary, Events Summary]
tags: [obsidian-explorer, summary, events]
type: events-summary
version: "${this.getPluginVersion()}"
cssclasses: obsidianObserverEventsTable
---

# ObsidianObserver Events Summary

This file provides a summary of all ObsidianObserver events.

> **Note**: This summary uses the \`obsidianObserverEventsTable\` CSS class for enhanced table styling. The CSS class is automatically applied to this note.

## DataView Query Examples

### Basic Event Queries
\`\`\`dataview
TABLE OOEvent_GUID, OOEvent_Type, OOEvent_FileName, OOEvent_VaultName, OOEvent_LocalTimestamp
FROM "${this.config.eventsFolder}/events"
WHERE OOEvent_Type = "open"
SORT OOEvent_LocalTimestamp DESC
LIMIT 10
\`\`\`

\`\`\`dataview
TABLE OOEvent_GUID, OOEvent_Type, OOEvent_FileName, OOEvent_VaultName, OOEvent_LocalTimestamp
FROM "${this.config.eventsFolder}/events"
WHERE OOEvent_Type = "save"
SORT OOEvent_LocalTimestamp DESC
LIMIT 5
\`\`\`

\`\`\`dataview
TABLE OOEvent_GUID, OOEvent_Type, OOEvent_FileName, OOEvent_VaultName, OOEvent_LocalTimestamp
FROM "${this.config.eventsFolder}/events"
WHERE OOEvent_Type = "close"
SORT OOEvent_LocalTimestamp DESC
LIMIT 5
\`\`\`

### File Management Events
\`\`\`dataview
TABLE OOEvent_GUID, OOEvent_Type, OOEvent_FileName, OOEvent_VaultName, OOEvent_LocalTimestamp
FROM "${this.config.eventsFolder}/events"
WHERE OOEvent_Type = "create"
SORT OOEvent_LocalTimestamp DESC
LIMIT 10
\`\`\`

\`\`\`dataview
TABLE OOEvent_GUID, OOEvent_Type, OOEvent_FileName, OOEvent_VaultName, OOEvent_LocalTimestamp
FROM "${this.config.eventsFolder}/events"
WHERE OOEvent_Type = "delete"
SORT OOEvent_LocalTimestamp DESC
LIMIT 10
\`\`\`

\`\`\`dataview
TABLE OOEvent_GUID, OOEvent_Type, OOEvent_FileName, OOEvent_OldPath, OOEvent_NewPath, OOEvent_LocalTimestamp
FROM "${this.config.eventsFolder}/events"
WHERE OOEvent_Type = "rename"
SORT OOEvent_LocalTimestamp DESC
LIMIT 10
\`\`\`

### Advanced Queries
\`\`\`dataview
TABLE OOEvent_GUID, OOEvent_Type, OOEvent_FileName, OOEvent_VaultName, OOEvent_Timestamp
FROM "${this.config.eventsFolder}/events"
WHERE contains(OOEvent_FilePath, "Projects")
SORT OOEvent_Timestamp DESC
\`\`\`

\`\`\`dataview
TABLE OOEvent_GUID, OOEvent_Type, OOEvent_FileName, OOEvent_VaultName, OOEvent_Timestamp
FROM "${this.config.eventsFolder}/events"
WHERE OOEvent_GUID = "ABC123DEF456GHI789JKL012"
\`\`\`

### File Size Analysis
\`\`\`dataview
TABLE OOEvent_FileName, OOEvent_FileSize, OOEvent_Type, OOEvent_Timestamp
FROM "${this.config.eventsFolder}/events"
WHERE OOEvent_FileSize
SORT OOEvent_FileSize DESC
LIMIT 10
\`\`\`

### Recent Activity
\`\`\`dataview
TABLE OOEvent_FileName, OOEvent_Type, OOEvent_Timestamp
FROM "${this.config.eventsFolder}/events"
SORT OOEvent_Timestamp DESC
LIMIT 20
\`\`\`

## Event Statistics

### Event Type Distribution
\`\`\`dataview
TABLE length(rows) as "Count"
FROM "${this.config.eventsFolder}/events"
GROUP BY OOEvent_Type
SORT Count DESC
\`\`\`

### Vault Activity
\`\`\`dataview
TABLE length(rows) as "Count"
FROM "${this.config.eventsFolder}/events"
GROUP BY OOEvent_VaultName
SORT Count DESC
\`\`\`

### File Activity
\`\`\`dataview
TABLE OOEvent_FileName, length(rows) as "Event Count"
FROM "${this.config.eventsFolder}/events"
GROUP BY OOEvent_FileName
SORT "Event Count" DESC
LIMIT 20
\`\`\`

### Daily Activity
\`\`\`dataview
TABLE date(OOEvent_Timestamp) as "Date", length(rows) as "Events"
FROM "${this.config.eventsFolder}/events"
GROUP BY date(OOEvent_Timestamp)
SORT "Date" DESC
LIMIT 30
\`\`\`
`;
      const existingFile = this.app.vault.getAbstractFileByPath(summaryPath);
      if (existingFile) {
        this.log(`[ObsidianObserver] Summary file already exists: ${summaryPath}`);
        return;
      }
      await this.app.vault.create(summaryPath, summaryContent);
      this.log(`[ObsidianObserver] Created summary file: ${summaryPath}`);
      this.app.workspace.trigger("file-explorer:refresh");
    } catch (error) {
      console.error(`[ObsidianObserver] Error creating summary file:`, error);
    }
  }
  async createEventsBaseFile() {
    try {
      const basePath = `${this.config.eventsFolder}/EventsBase.base`;
      const baseContent = `formulas:
  Time: OOEvent_LocalTimestamp
  File: link(OOEvent_Filename)
  Untitled: OOEvent_LocalTimestamp - now()
  When: (now() - date(OOEvent_LocalTimestamp.slice(0,10))).days
  FileLink: file(OOEvent_FilePath)
  Accessed: date(OOEvent_LocalTimestamp.slice(0,19)).relative()
properties:
  note.OOEvent_Type:
    displayName: Event
  note.OOEvent_LocalTimestamp:
    displayName: Timestamp
  file.name:
    displayName: Note
  note.OOEvent_Hostname:
    displayName: Hostname
views:
  - type: table
    name: Table
    filters:
      and:
        - file.hasProperty("OOEvent_GUID")
    order:
      - OOEvent_Type
      - formula.File
      - OOEvent_LocalTimestamp
      - OOEvent_Timestamp
    sort: []
    columnSize:
      formula.File: 150
  - type: table
    name: Today's File Accesses
    filters:
      and:
        - formula.When <= 1
        - OOEvent_Type.containsAny("open", "save", "rename", "delete")
    order:
      - formula.FileLink
      - OOEvent_Type
      - formula.Accessed
      - OOEvent_Hostname
    sort:
      - property: formula.Accessed
        direction: DESC
      - property: OOEvent_LocalTimestamp
        direction: ASC
      - property: formula.When
        direction: ASC
    columnSize:
      formula.FileLink: 140
      note.OOEvent_Type: 117
      note.OOEvent_LocalTimestamp: 213`;
      const existingFile = this.app.vault.getAbstractFileByPath(basePath);
      if (existingFile) {
        this.log(`[ObsidianObserver] EventsBase.base file already exists: ${basePath}`);
        return;
      }
      await this.app.vault.create(basePath, baseContent);
      this.log(`[ObsidianObserver] Created EventsBase.base file: ${basePath}`);
    } catch (error) {
      console.error(`[ObsidianObserver] Error creating EventsBase.base file:`, error);
    }
  }
  async createCSSFile() {
    try {
      const cssPath = `.obsidian/snippets/obsidianObserverEventsTable.css`;
      const cssContent = `/* === Compact, styled Dataview tables for Obsidian Observer Events === */

.obsidianObserverEventsTable
{
  version: "${this.getPluginVersion()}"
}

/* Scope: only tables inside .obsidianObserverEventsTable blocks */
.obsidianObserverEventsTable table.dataview,
.obsidianObserverEventsTable .table-view-table,
.markdown-source-view.mod-cm6 .obsidianObserverEventsTable .table-view-table {
  table-layout: fixed !important;
  width: 90% !important;
  border-collapse: collapse !important;

  font-size: 8pt !important; 
  line-height: 1.2 !important;

  /* cleaned up: remove x-border; fix color var */
  border: 5px solid rgb(157, 241, 149) !important;
  border-radius: 4px !important;
  overflow: hidden !important;
}

/* Headers */
.obsidianObserverEventsTable table.dataview thead th,
.obsidianObserverEventsTable .table-view-table thead th {
  background-color: var(--background-modifier-hover) !important;
  color: var(--text-normal) !important;
  font-weight: 600 !important;
  padding: 2px 6px !important;
  text-align: left !important;

  /* keep your debug border, remove x-border */
  border-bottom: 2px solid orange !important;

  white-space: nowrap !important;
  overflow: hidden !important;
  text-overflow: ellipsis !important;

  /* critical: allow shrink */
  min-width: 0 !important;
}

/* Cells */
.obsidianObserverEventsTable table.dataview tbody td,
.obsidianObserverEventsTable .table-view-table tbody td {
  padding: 2px 6px !important;

  /* keep your debug border, remove x-border */
  border-bottom: 1px solid greenyellow !important;

  white-space: nowrap !important;
  overflow: hidden !important;
  text-overflow: ellipsis !important;

  /* critical: allow shrink */
  min-width: 0 !important;
}

/* Make cell contents shrinkable & ellipsize (anchors/spans often block) */
.obsidianObserverEventsTable table.dataview th > *,
.obsidianObserverEventsTable table.dataview td > *,
.obsidianObserverEventsTable .table-view-table th > *,
.obsidianObserverEventsTable .table-view-table td > * {
  min-width: 0 !important;
  max-width: 100% !important;
  display: inline-block !important;  /* enables overflow/ellipsis reliably */
  overflow: hidden !important;
  text-overflow: ellipsis !important;
  vertical-align: bottom;
}

/* Column sizing \u2014 compact by default (kept your widths & debug colors) */
.obsidianObserverEventsTable table.dataview th,
.obsidianObserverEventsTable table.dataview td,
.obsidianObserverEventsTable .table-view-table th,
.obsidianObserverEventsTable .table-view-table td {
  width: 50px !important;
  max-width: 50px !important;
  min-width: 0 !important;
  background-color: darkslategray !important;
}

/* First column (File) wider */
.obsidianObserverEventsTable table.dataview th:first-child,
.obsidianObserverEventsTable table.dataview td:first-child,
.obsidianObserverEventsTable .table-view-table th:first-child,
.obsidianObserverEventsTable .table-view-table td:first-child {
  width: 20px !important;
  max-width: 20px !important;
  x-background-color: red !important;
  font-weight: bold !important;
}

/* Second column (Type) \u2014 centered + bold */
.obsidianObserverEventsTable table.dataview th:nth-child(2),
.obsidianObserverEventsTable table.dataview td:nth-child(2),
.obsidianObserverEventsTable .table-view-table th:nth-child(2),
.obsidianObserverEventsTable .table-view-table td:nth-child(2) {
  width: 10px !important;
  max-width: 10px !important;
  text-align: center !important;
  font-weight: bold !important;
  x-background-color: lightgreen !important;
}

/* Third column (Timestamp) \u2014 monospace */
.obsidianObserverEventsTable table.dataview th:nth-child(3),
.obsidianObserverEventsTable table.dataview td:nth-child(3),
.obsidianObserverEventsTable .table-view-table th:nth-child(3),
.obsidianObserverEventsTable .table-view-table td:nth-child(3) {
  width: 20px !important;
  max-width: 20px !important;
  font-family: monospace !important;
  x-background-color: purple !important;
}

/* Zebra striping
.obsidianObserverEventsTable table.dataview tbody tr:nth-child(even) td {
  background-color: #f5f5f5 !important;
}
.obsidianObserverEventsTable table.dataview tbody tr:hover td {
  background-color: #e0e0e0 !important;
}
.theme-dark .obsidianObserverEventsTable table.dataview tbody tr:nth-child(even) td {
  background-color: #2a2a2a !important;
}
.theme-dark .obsidianObserverEventsTable table.dataview tbody tr:hover td {
  background-color: #3a3a3a !important;
}
*/`;
      const existingFile = this.app.vault.getAbstractFileByPath(cssPath);
      if (existingFile) {
        this.log(`[ObsidianObserver] CSS file already exists: ${cssPath}`);
        return;
      }
      await this.app.vault.create(cssPath, cssContent);
      this.log(`[ObsidianObserver] Created CSS file: ${cssPath}`);
    } catch (error) {
      console.error(`[ObsidianObserver] Error creating CSS file:`, error);
    }
  }
  async createMainSummaryNote() {
    try {
      const summaryPath = `${this.config.eventsFolder}/EventsSummary.md`;
      const summaryContent = `---
aliases: [ObsidianObserver Main Summary, Events Summary]
tags: [obsidian-explorer, summary, events, main]
type: events-summary
version: "${this.getPluginVersion()}"
cssclasses: obsidianObserverEventsTable
---

# ObsidianObserver Events Summary

This file provides comprehensive DataView reports for common use-cases with ObsidianObserver events.

> **Note**: This summary uses the \`obsidianObserverEventsTable\` CSS class for enhanced table styling. The CSS class is automatically applied to this note.

## Quick Overview

### Recent Activity (Last 20 Events)
\`\`\`dataview
TABLE WITHOUT ID
  regexreplace(OOEvent_FileName, ".md$", "") AS "File",
  upper(OOEvent_Type) AS "Type",
  OOEvent_Hostname AS "Host",
  dateformat(OOEvent_LocalTimestamp, "yyyy-MM-dd HH:mm:ss") AS "When"
FROM "${this.config.eventsFolder}/events"
SORT OOEvent_LocalTimestamp DESC
LIMIT 20
\`\`\`

### Event Type Distribution
\`\`\`dataview
TABLE length(rows) as "Count"
FROM "${this.config.eventsFolder}/events"
GROUP BY OOEvent_Type
SORT Count DESC
\`\`\`

### Most Active Files
\`\`\`dataviewjs
const ignore = ["ready", "PLUGINLOADED", "QUIT"];

const pages = dv.pages('"${this.config.eventsFolder}/events"')
  .where(p => p.OOEvent_FileName && 
              !ignore.includes(p.OOEvent_Type) && 
              !p.OOEvent_FilePath.includes('${this.config.eventsFolder}'));

const grouped = new Map();

for (let page of pages) {
  const key = page.OOEvent_FileName;
  if (!grouped.has(key)) grouped.set(key, []);
  grouped.get(key).push(page);
}

const result = Array.from(grouped.entries())
  .map(([file, rows]) => {
    const opens = rows.filter(r => r.OOEvent_Type === "open").length;
    const saves = rows.filter(r => r.OOEvent_Type === "save").length;
    const closes = rows.filter(r => r.OOEvent_Type === "close").length;
    return {
      File: file.replace(/\\.md$/, ""),
      Opens: opens,
      Saves: saves,
      Closes: closes,
      Total: rows.length
    };
  })
  .filter(row => row.Saves > 0 || row.Closes > 0) // Filter out files that only have opens
  .sort((a, b) => b.Total - a.Total)
  .slice(0, 15);

// Build the HTML table
let html = \`
<div class="activity-log-table">
<table>
  <thead>
    <tr>
      <th style="width: 40%; text-align: left;">File</th>
      <th style="text-align: right;">Total</th>
      <th style="text-align: right;">Opens</th>
      <th style="text-align: right;">Saves</th>
      <th style="text-align: right;">Closes</th>
    </tr>
  </thead>
  <tbody>
\`;

for (let row of result) {
  // Create a link to the original note
  const fileLink = \`[[\${row.File}]]\`;
  html += \`
    <tr>
      <td style="white-space: nowrap; overflow: hidden; text-overflow: ellipsis;">\${fileLink}</td>
      <td style="text-align: right;">\${row.Total}</td>
      <td style="text-align: right;">\${row.Opens}</td>
      <td style="text-align: right;">\${row.Saves}</td>
      <td style="text-align: right;">\${row.Closes}</td>
    </tr>
  \`;
}

html += \`
  </tbody>
</table>
</div>
\`;

dv.container.innerHTML = html;
\`\`\`

## File Operations

### Recent File Opens
\`\`\`dataview
TABLE WITHOUT ID
  regexreplace(OOEvent_FileName, ".md$", "") AS "File",
  upper(OOEvent_Type) AS "Type",
  OOEvent_Hostname AS "Host",
  dateformat(OOEvent_LocalTimestamp, "yyyy-MM-dd HH:mm:ss") AS "When"
FROM "${this.config.eventsFolder}/events"
WHERE OOEvent_Type = "open"
SORT OOEvent_LocalTimestamp DESC
LIMIT 10
\`\`\`

### Recent File Saves
\`\`\`dataview
TABLE WITHOUT ID
  regexreplace(OOEvent_FileName, ".md$", "") AS "File",
  upper(OOEvent_Type) AS "Type",
  OOEvent_Hostname AS "Host",
  dateformat(OOEvent_LocalTimestamp, "yyyy-MM-dd HH:mm:ss") AS "When"
FROM "${this.config.eventsFolder}/events"
WHERE OOEvent_Type = "save"
SORT OOEvent_LocalTimestamp DESC
LIMIT 10
\`\`\`

### Recent File Closes
\`\`\`dataview
TABLE WITHOUT ID
  regexreplace(OOEvent_FileName, ".md$", "") AS "File",
  upper(OOEvent_Type) AS "Type",
  OOEvent_Hostname AS "Host",
  dateformat(OOEvent_LocalTimestamp, "yyyy-MM-dd HH:mm:ss") AS "When"
FROM "${this.config.eventsFolder}/events"
WHERE OOEvent_Type = "close"
SORT OOEvent_LocalTimestamp DESC
LIMIT 10
\`\`\`

## File Management

### Recently Created Files
\`\`\`dataview
TABLE WITHOUT ID
  regexreplace(OOEvent_FileName, ".md$", "") AS "File",
  upper(OOEvent_Type) AS "Type",
  OOEvent_Hostname AS "Host",
  dateformat(OOEvent_LocalTimestamp, "yyyy-MM-dd HH:mm:ss") AS "When"
FROM "${this.config.eventsFolder}/events"
WHERE OOEvent_Type = "create"
SORT OOEvent_LocalTimestamp DESC
LIMIT 10
\`\`\`

### Recently Deleted Files
\`\`\`dataview
TABLE WITHOUT ID
  regexreplace(OOEvent_FileName, ".md$", "") AS "File",
  upper(OOEvent_Type) AS "Type",
  OOEvent_Hostname AS "Host",
  dateformat(OOEvent_LocalTimestamp, "yyyy-MM-dd HH:mm:ss") AS "When"
FROM "${this.config.eventsFolder}/events"
WHERE OOEvent_Type = "delete"
SORT OOEvent_LocalTimestamp DESC
LIMIT 10
\`\`\`

### Recently Renamed Files
\`\`\`dataview
TABLE WITHOUT ID
  regexreplace(OOEvent_FileName, ".md$", "") AS "File",
  upper(OOEvent_Type) AS "Type",
  OOEvent_Hostname AS "Host",
  OOEvent_OldPath AS "Old Path",
  OOEvent_NewPath AS "New Path",
  dateformat(OOEvent_LocalTimestamp, "yyyy-MM-dd HH:mm:ss") AS "When"
FROM "${this.config.eventsFolder}/events"
WHERE OOEvent_Type = "rename"
SORT OOEvent_LocalTimestamp DESC
LIMIT 10
\`\`\`

## Advanced Analysis

### Project-Related Activity
\`\`\`dataview
TABLE WITHOUT ID
  regexreplace(OOEvent_FileName, ".md$", "") AS "File",
  upper(OOEvent_Type) AS "Type",
  OOEvent_Hostname AS "Host",
  dateformat(OOEvent_LocalTimestamp, "yyyy-MM-dd HH:mm:ss") AS "When"
FROM "${this.config.eventsFolder}/events"
WHERE contains(OOEvent_FilePath, "Projects")
SORT OOEvent_LocalTimestamp DESC
LIMIT 15
\`\`\`

### People-Related Activity
\`\`\`dataview
TABLE WITHOUT ID
  regexreplace(OOEvent_FileName, ".md$", "") AS "File",
  upper(OOEvent_Type) AS "Type",
  OOEvent_Hostname AS "Host",
  dateformat(OOEvent_LocalTimestamp, "yyyy-MM-dd HH:mm:ss") AS "When"
FROM "${this.config.eventsFolder}/events"
WHERE contains(OOEvent_FilePath, "People")
SORT OOEvent_LocalTimestamp DESC
LIMIT 15
\`\`\`

### Meeting-Related Activity
\`\`\`dataview
TABLE WITHOUT ID
  regexreplace(OOEvent_FileName, ".md$", "") AS "File",
  upper(OOEvent_Type) AS "Type",
  OOEvent_Hostname AS "Host",
  dateformat(OOEvent_LocalTimestamp, "yyyy-MM-dd HH:mm:ss") AS "When"
FROM "${this.config.eventsFolder}/events"
WHERE contains(OOEvent_FileName, "Meeting")
SORT OOEvent_LocalTimestamp DESC
LIMIT 15
\`\`\`

## Time-Based Analysis

### Today's Activity
\`\`\`dataview
TABLE WITHOUT ID
  regexreplace(OOEvent_FileName, ".md$", "") AS "File",
  upper(OOEvent_Type) AS "Type",
  OOEvent_Hostname AS "Host",
  dateformat(OOEvent_LocalTimestamp, "yyyy-MM-dd HH:mm:ss") AS "When"
FROM "${this.config.eventsFolder}/events"
WHERE date(OOEvent_LocalTimestamp) = date(today)
SORT OOEvent_LocalTimestamp DESC
\`\`\`

### This Week's Activity
\`\`\`dataview
TABLE WITHOUT ID
  regexreplace(OOEvent_FileName, ".md$", "") AS "File",
  upper(OOEvent_Type) AS "Type",
  OOEvent_Hostname AS "Host",
  dateformat(OOEvent_LocalTimestamp, "yyyy-MM-dd HH:mm:ss") AS "When"
FROM "${this.config.eventsFolder}/events"
WHERE date(OOEvent_LocalTimestamp) >= date(today) - dur(7 days)
SORT OOEvent_LocalTimestamp DESC
\`\`\`

### Daily Activity Summary (Last 30 Days)
\`\`\`dataview
TABLE date(OOEvent_LocalTimestamp) as "Date", length(rows) as "Events"
FROM "${this.config.eventsFolder}/events"
GROUP BY date(OOEvent_LocalTimestamp)
SORT "Date" DESC
LIMIT 30
\`\`\`

## File Size Analysis

### Files with Size Information
\`\`\`dataview
TABLE WITHOUT ID
  regexreplace(OOEvent_FileName, ".md$", "") AS "File",
  OOEvent_FileSize AS "Size",
  upper(OOEvent_Type) AS "Type",
  OOEvent_Hostname AS "Host",
  dateformat(OOEvent_LocalTimestamp, "yyyy-MM-dd HH:mm:ss") AS "When"
FROM "${this.config.eventsFolder}/events"
WHERE OOEvent_FileSize
SORT OOEvent_FileSize DESC
LIMIT 10
\`\`\`

## Search and Filter

### Search by File Name
\`\`\`dataview
TABLE WITHOUT ID
  regexreplace(OOEvent_FileName, ".md$", "") AS "File",
  upper(OOEvent_Type) AS "Type",
  OOEvent_Hostname AS "Host",
  dateformat(OOEvent_LocalTimestamp, "yyyy-MM-dd HH:mm:ss") AS "When"
FROM "${this.config.eventsFolder}/events"
WHERE contains(OOEvent_FileName, "YOUR_SEARCH_TERM")
SORT OOEvent_LocalTimestamp DESC
\`\`\`

### Search by GUID
\`\`\`dataview
TABLE WITHOUT ID
  OOEvent_GUID AS "GUID",
  regexreplace(OOEvent_FileName, ".md$", "") AS "File",
  upper(OOEvent_Type) AS "Type",
  OOEvent_Hostname AS "Host",
  dateformat(OOEvent_LocalTimestamp, "yyyy-MM-dd HH:mm:ss") AS "When"
FROM "${this.config.eventsFolder}/events"
WHERE OOEvent_GUID = "YOUR_GUID_HERE"
\`\`\`

## Event Types Explained

- **open**: File opened in Obsidian editor
- **save**: File modified and saved
- **close**: File closed in editor
- **create**: New file created
- **delete**: File deleted from vault
- **rename**: File renamed or moved (includes old and new paths)
- **ready**: Obsidian application fully loaded and ready
- **quit**: Obsidian application closing
- **PluginLoaded**: ObsidianObserver plugin loaded and initialized

## Metadata Fields

- **OOEvent_GUID**: Unique Base32 identifier for each event
- **OOEvent_Timestamp**: ISO timestamp of the event (UTC)
- **OOEvent_LocalTimestamp**: Local timestamp of the event (user's timezone)
- **OOEvent_Type**: Type of file operation
- **OOEvent_FilePath**: Full path to the file
- **OOEvent_FileName**: Name of the file
- **OOEvent_VaultName**: Name of the vault
- **OOEvent_Hostname**: Hostname of the machine where the event occurred
- **OOEvent_LastModified**: Last modification time of the file
- **OOEvent_Created**: When the event note was created
- **OOEvent_FileSize**: Size of the file in bytes
- **OOEvent_OldPath**: Previous path (for rename events)
- **OOEvent_NewPath**: New path (for rename events)
`;
      const existingFile = this.app.vault.getAbstractFileByPath(summaryPath);
      if (existingFile) {
        this.log(`[ObsidianObserver] Main summary file already exists: ${summaryPath}`);
        return;
      }
      await this.app.vault.create(summaryPath, summaryContent);
      this.log(`[ObsidianObserver] Created main summary file: ${summaryPath}`);
      await this.createEventsBaseFile();
      await this.createCSSFile();
      this.app.workspace.trigger("file-explorer:refresh");
    } catch (error) {
      console.error(`[ObsidianObserver] Error creating main summary file:`, error);
    }
  }
  async refreshMainSummaryNote() {
    try {
      const summaryPath = `${this.config.eventsFolder}/EventsSummary.md`;
      const basePath = `${this.config.eventsFolder}/EventsBase.base`;
      const cssPath = `.obsidian/snippets/obsidianObserverEventsTable.css`;
      const existingSummaryFile = this.app.vault.getAbstractFileByPath(summaryPath);
      if (existingSummaryFile) {
        await this.app.vault.delete(existingSummaryFile);
        this.log(`[ObsidianObserver] Deleted existing summary file: ${summaryPath}`);
      }
      const existingBaseFile = this.app.vault.getAbstractFileByPath(basePath);
      if (existingBaseFile) {
        await this.app.vault.delete(existingBaseFile);
        this.log(`[ObsidianObserver] Deleted existing EventsBase.base file: ${basePath}`);
      }
      const existingCSSFile = this.app.vault.getAbstractFileByPath(cssPath);
      if (existingCSSFile) {
        await this.app.vault.delete(existingCSSFile);
        this.log(`[ObsidianObserver] Deleted existing CSS file: ${cssPath}`);
      }
      await this.createMainSummaryNote();
      this.log(`[ObsidianObserver] Refreshed main summary file: ${summaryPath}`);
    } catch (error) {
      console.error(`[ObsidianObserver] Error refreshing main summary file:`, error);
      throw error;
    }
  }
};

// src/eventHandlers.ts
var import_obsidian = __toModule(require("obsidian"));
init_utils();
var EventHandlers = class {
  constructor(app, logger) {
    this.eventRefs = [];
    this.isProcessingEvent = false;
    this.excludedFiles = [];
    this.hasLoggedAppReady = false;
    this.app = app;
    this.logger = logger;
    this.loggerConfig = logger.getConfig();
  }
  log(message, ...args) {
    if (this.loggerConfig.enableConsoleLog) {
      console.log(message, ...args);
    }
  }
  updateLoggerConfig(newConfig) {
    this.loggerConfig = newConfig;
    this.log("[ObsidianObserver] Event handlers configuration updated:", newConfig);
  }
  getHostname() {
    try {
      if (typeof require !== "undefined") {
        try {
          const os = require("os");
          if (os && typeof os.hostname === "function") {
            const hostname = os.hostname();
            this.log("[ObsidianObserver] os.hostname() result:", hostname);
            if (hostname && hostname.trim() && hostname !== "localhost" && hostname !== "127.0.0.1" && hostname !== "::1") {
              return hostname;
            }
          }
        } catch (osError) {
          this.log("[ObsidianObserver] os module not available or error:", osError);
        }
      }
      if (typeof process !== "undefined" && process.env) {
        if (process.env.HOSTNAME && process.env.HOSTNAME !== "localhost") {
          return process.env.HOSTNAME;
        }
        if (process.env.COMPUTERNAME && process.env.COMPUTERNAME !== "localhost") {
          return process.env.COMPUTERNAME;
        }
        if (process.env.USERDOMAIN && process.env.USERDOMAIN !== "localhost") {
          return process.env.USERDOMAIN;
        }
        if (process.env.USER && process.env.USER !== "localhost") {
          return process.env.USER;
        }
      }
      let machineId = "obsidian";
      if (this.app && this.app.vault) {
        try {
          const vaultName = this.app.vault.getName();
          if (vaultName && vaultName.trim() && vaultName !== "vault") {
            const cleanName = vaultName.replace(/[^a-zA-Z0-9]/g, "").toLowerCase();
            if (cleanName.length > 0) {
              machineId = cleanName;
            }
          }
        } catch (vaultError) {
          this.log("[ObsidianObserver] Could not get vault name:", vaultError);
        }
      }
      let identifier = machineId;
      if (typeof navigator !== "undefined" && navigator.platform) {
        if (navigator.platform.includes("Mac")) {
          identifier += "-mac";
        } else if (navigator.platform.includes("Win")) {
          identifier += "-win";
        } else if (navigator.platform.includes("Linux")) {
          identifier += "-linux";
        }
      }
      const sessionId = Math.random().toString(36).substring(2, 6);
      const finalId = `${identifier}-${sessionId}`;
      this.log("[ObsidianObserver] Generated machine identifier:", finalId);
      return finalId;
    } catch (error) {
      console.warn("[ObsidianObserver] Could not determine hostname:", error);
      const fallbackId = Math.random().toString(36).substring(2, 8);
      return `fallback-${fallbackId}`;
    }
  }
  shouldExcludeFile(filePath) {
    if (filePath.startsWith(this.loggerConfig.eventsFolder)) {
      return true;
    }
    if (filePath.startsWith(".obsidian/")) {
      return true;
    }
    if (filePath.includes(".temp") || filePath.includes(".tmp") || filePath.includes(".cache")) {
      return true;
    }
    if (filePath.startsWith(".")) {
      return true;
    }
    return this.excludedFiles.includes(filePath);
  }
  registerEventHandlers() {
    try {
      const openRef = this.app.workspace.on("file-open", (file) => {
        if (file) {
          this.handleFileOpen(file);
        }
      });
      this.eventRefs.push(openRef);
      const saveRef = this.app.vault.on("modify", (file) => {
        if (file instanceof import_obsidian.TFile) {
          this.handleFileSave(file);
        }
      });
      this.eventRefs.push(saveRef);
      const renameRef = this.app.vault.on("rename", (file, oldPath) => {
        if (file instanceof import_obsidian.TFile) {
          this.handleFileRename(file, oldPath);
        }
      });
      this.eventRefs.push(renameRef);
      const deleteRef = this.app.vault.on("delete", (file) => {
        if (file instanceof import_obsidian.TFile) {
          this.handleFileDelete(file);
        }
      });
      this.eventRefs.push(deleteRef);
      const readyRef = this.app.workspace.on("resize", () => {
        this.handleAppReady();
      });
      this.eventRefs.push(readyRef);
      this.log("[ObsidianObserver] Event handlers registered successfully (open, save, rename, delete, layout-ready)");
    } catch (error) {
      console.error("[ObsidianObserver] Error registering event handlers:", error);
    }
  }
  unregisterEventHandlers() {
    try {
      for (const eventRef of this.eventRefs) {
        this.app.workspace.offref(eventRef);
      }
      this.eventRefs = [];
      this.logger.flushBuffer();
      this.log("[ObsidianObserver] Event handlers unregistered successfully");
    } catch (error) {
      console.error("[ObsidianObserver] Error unregistering event handlers:", error);
    }
  }
  async handleFileOpen(file) {
    try {
      if (this.isProcessingEvent) {
        return;
      }
      if (this.shouldExcludeFile(file.path)) {
        return;
      }
      this.isProcessingEvent = true;
      let metadata;
      try {
        const stat = await this.app.vault.adapter.stat(file.path);
        if (stat) {
          metadata = {
            lastModified: new Date(stat.mtime).toISOString(),
            fileSize: stat.size
          };
        }
      } catch (error) {
        console.warn("[ObsidianObserver] Error getting file metadata:", error);
      }
      const eventLog = {
        guid: generateBase32Guid(),
        timestamp: new Date().toISOString(),
        eventType: "open",
        filePath: file.path,
        fileName: file.name,
        vaultName: this.app.vault.getName(),
        hostname: this.getHostname(),
        metadata
      };
      await this.logger.logEvent(eventLog);
    } catch (error) {
      console.error("[ObsidianObserver] Error handling file open event:", error);
    } finally {
      this.isProcessingEvent = false;
    }
  }
  async handleFileSave(file) {
    try {
      if (this.isProcessingEvent) {
        return;
      }
      if (this.shouldExcludeFile(file.path)) {
        return;
      }
      this.isProcessingEvent = true;
      let metadata;
      try {
        const stat = await this.app.vault.adapter.stat(file.path);
        if (stat) {
          metadata = {
            lastModified: new Date(stat.mtime).toISOString(),
            fileSize: stat.size
          };
        }
      } catch (error) {
        console.warn("[ObsidianObserver] Error getting file metadata:", error);
      }
      const eventLog = {
        guid: generateBase32Guid(),
        timestamp: new Date().toISOString(),
        eventType: "save",
        filePath: file.path,
        fileName: file.name,
        vaultName: this.app.vault.getName(),
        hostname: this.getHostname(),
        metadata
      };
      await this.logger.logEvent(eventLog);
    } catch (error) {
      console.error("[ObsidianObserver] Error handling file save event:", error);
    } finally {
      this.isProcessingEvent = false;
    }
  }
  async handleFileRename(file, oldPath) {
    try {
      if (this.isProcessingEvent) {
        return;
      }
      if (this.shouldExcludeFile(file.path) || this.shouldExcludeFile(oldPath)) {
        return;
      }
      this.isProcessingEvent = true;
      let metadata;
      try {
        const stat = await this.app.vault.adapter.stat(file.path);
        if (stat) {
          metadata = {
            lastModified: new Date(stat.mtime).toISOString(),
            fileSize: stat.size,
            oldPath,
            newPath: file.path
          };
        }
      } catch (error) {
        console.warn("[ObsidianObserver] Error getting file metadata:", error);
      }
      const eventLog = {
        guid: generateBase32Guid(),
        timestamp: new Date().toISOString(),
        eventType: "rename",
        filePath: file.path,
        fileName: file.name,
        vaultName: this.app.vault.getName(),
        hostname: this.getHostname(),
        metadata
      };
      await this.logger.logEvent(eventLog);
    } catch (error) {
      console.error("[ObsidianObserver] Error handling file rename event:", error);
    } finally {
      this.isProcessingEvent = false;
    }
  }
  async handleFileDelete(file) {
    try {
      if (this.isProcessingEvent) {
        return;
      }
      if (this.shouldExcludeFile(file.path)) {
        return;
      }
      this.isProcessingEvent = true;
      const eventLog = {
        guid: generateBase32Guid(),
        timestamp: new Date().toISOString(),
        eventType: "delete",
        filePath: file.path,
        fileName: file.name,
        vaultName: this.app.vault.getName(),
        hostname: this.getHostname(),
        metadata: {
          lastModified: new Date().toISOString()
        }
      };
      await this.logger.logEvent(eventLog);
    } catch (error) {
      console.error("[ObsidianObserver] Error handling file delete event:", error);
    } finally {
      this.isProcessingEvent = false;
    }
  }
  async handleAppReady() {
    try {
      if (this.hasLoggedAppReady) {
        return;
      }
      if (this.isProcessingEvent) {
        return;
      }
      this.isProcessingEvent = true;
      const eventLog = {
        guid: generateBase32Guid(),
        timestamp: new Date().toISOString(),
        eventType: "ready",
        filePath: "",
        fileName: "",
        vaultName: this.app.vault.getName(),
        hostname: this.getHostname(),
        metadata: {
          lastModified: new Date().toISOString()
        }
      };
      await this.logger.logEvent(eventLog);
      this.hasLoggedAppReady = true;
    } catch (error) {
      console.error("[ObsidianObserver] Error handling app ready event:", error);
    } finally {
      this.isProcessingEvent = false;
    }
  }
  async testLogging() {
    try {
      const testFile = this.app.workspace.getActiveFile();
      if (testFile) {
        await this.handleFileOpen(testFile);
      } else {
        const eventLog = {
          guid: generateBase32Guid(),
          timestamp: new Date().toISOString(),
          eventType: "open",
          filePath: "test-file.md",
          fileName: "test-file.md",
          vaultName: this.app.vault.getName(),
          hostname: this.getHostname(),
          metadata: {
            lastModified: new Date().toISOString(),
            fileSize: 1024
          }
        };
        await this.logger.logEvent(eventLog);
      }
    } catch (error) {
      console.error("[ObsidianObserver] Error in test logging:", error);
    }
  }
};

// src/main.ts
var DEFAULT_SETTINGS = {
  eventsFolder: "ObsidianObserver",
  enableConsoleLog: true
};
var ObsidianObserverPlugin = class extends import_obsidian2.Plugin {
  constructor(app, manifest) {
    super(app, manifest);
    this.settings = { ...DEFAULT_SETTINGS };
  }
  log(message, ...args) {
    if (this.settings.enableConsoleLog) {
      console.log(message, ...args);
    }
  }
  async onload() {
    this.log("[ObsidianObserver] Loading plugin...");
    try {
      await this.loadSettings();
      const loggerConfig = {
        eventsFolder: this.settings.eventsFolder,
        enableConsoleLog: this.settings.enableConsoleLog
      };
      this.logger = new EventLogger(this.app, loggerConfig, this.manifest.version);
      await this.logger.ensureEventsDirectoryExists();
      await this.logger.createSummaryNote();
      await this.logger.createMainSummaryNote();
      this.eventHandlers = new EventHandlers(this.app, this.logger);
      this.eventHandlers.registerEventHandlers();
      this.registerQuitDetectionEvents();
      this.addSettingTab(new ObsidianObserverSettingTab(this.app, this));
      this.addCommand({
        id: "flush-obsidian-observer-buffer",
        name: "Flush ObsidianObserver Buffer",
        callback: async () => {
          await this.logger.flushBuffer();
          this.app.workspace.trigger("file-explorer:refresh");
          new import_obsidian2.Notice("Buffer flushed to event notes!");
        }
      });
      this.addCommand({
        id: "obsidian-observer-refresh-summary",
        name: "ObsidianObserver: Refresh Summary",
        callback: async () => {
          await this.logger.refreshMainSummaryNote();
          this.app.workspace.trigger("file-explorer:refresh");
          new import_obsidian2.Notice("Events summary refreshed!");
        }
      });
      this.addCommand({
        id: "obsidian-observer-debug-hostname",
        name: "ObsidianObserver: Debug Hostname",
        callback: () => {
          const hostname = this.getHostname();
          this.log("[ObsidianObserver] Debug - Final hostname result:", hostname);
          new import_obsidian2.Notice(`Hostname: ${hostname}`);
        }
      });
      const { generateBase32Guid: generateBase32Guid2 } = await Promise.resolve().then(() => (init_utils(), utils_exports));
      const pluginLoadedEvent = {
        guid: generateBase32Guid2(),
        timestamp: new Date().toISOString(),
        eventType: "PluginLoaded",
        filePath: "",
        fileName: "",
        vaultName: this.app.vault.getName(),
        hostname: this.getHostname(),
        metadata: {
          lastModified: new Date().toISOString(),
          pluginVersion: this.manifest.version
        }
      };
      await this.logger.logEvent(pluginLoadedEvent);
      this.log("[ObsidianObserver] Plugin loaded successfully");
    } catch (error) {
      console.error("[ObsidianObserver] Error loading plugin:", error);
    }
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
  async updateSettings(updates) {
    Object.assign(this.settings, updates);
    await this.saveSettings();
    await this.updateLoggerConfiguration();
  }
  async isCSSEnabled() {
    try {
      const cssPath = `.obsidian/snippets/obsidianObserverEventsTable.css`;
      const cssFile = this.app.vault.getAbstractFileByPath(cssPath);
      return cssFile !== null;
    } catch (error) {
      this.log("[ObsidianObserver] Error checking CSS file:", error);
      return false;
    }
  }
  async updateLoggerConfiguration() {
    if (!this.logger)
      return;
    const newLoggerConfig = {
      eventsFolder: this.settings.eventsFolder,
      enableConsoleLog: this.settings.enableConsoleLog
    };
    this.logger.updateConfig(newLoggerConfig);
    if (this.eventHandlers) {
      this.eventHandlers.updateLoggerConfig(newLoggerConfig);
    }
    await this.logger.ensureEventsDirectoryExists();
    this.app.workspace.trigger("file-explorer:refresh");
  }
  getHostname() {
    try {
      if (typeof require !== "undefined") {
        try {
          const os = require("os");
          if (os && typeof os.hostname === "function") {
            const hostname = os.hostname();
            this.log("[ObsidianObserver] os.hostname() result:", hostname);
            if (hostname && hostname.trim() && hostname !== "localhost" && hostname !== "127.0.0.1" && hostname !== "::1") {
              return hostname;
            }
          }
        } catch (osError) {
          this.log("[ObsidianObserver] os module not available or error:", osError);
        }
      }
      if (typeof process !== "undefined" && process.env) {
        if (process.env.HOSTNAME && process.env.HOSTNAME !== "localhost") {
          return process.env.HOSTNAME;
        }
        if (process.env.COMPUTERNAME && process.env.COMPUTERNAME !== "localhost") {
          return process.env.COMPUTERNAME;
        }
        if (process.env.USERDOMAIN && process.env.USERDOMAIN !== "localhost") {
          return process.env.USERDOMAIN;
        }
        if (process.env.USER && process.env.USER !== "localhost") {
          return process.env.USER;
        }
      }
      let machineId = "obsidian";
      if (this.app && this.app.vault) {
        try {
          const vaultName = this.app.vault.getName();
          if (vaultName && vaultName.trim() && vaultName !== "vault") {
            const cleanName = vaultName.replace(/[^a-zA-Z0-9]/g, "").toLowerCase();
            if (cleanName.length > 0) {
              machineId = cleanName;
            }
          }
        } catch (vaultError) {
          this.log("[ObsidianObserver] Could not get vault name:", vaultError);
        }
      }
      let identifier = machineId;
      if (typeof navigator !== "undefined" && navigator.platform) {
        if (navigator.platform.includes("Mac")) {
          identifier += "-mac";
        } else if (navigator.platform.includes("Win")) {
          identifier += "-win";
        } else if (navigator.platform.includes("Linux")) {
          identifier += "-linux";
        }
      }
      const sessionId = Math.random().toString(36).substring(2, 6);
      const finalId = `${identifier}-${sessionId}`;
      this.log("[ObsidianObserver] Generated machine identifier:", finalId);
      return finalId;
    } catch (error) {
      console.warn("[ObsidianObserver] Could not determine hostname:", error);
      const fallbackId = Math.random().toString(36).substring(2, 8);
      return `fallback-${fallbackId}`;
    }
  }
  registerQuitDetectionEvents() {
    this.registerDomEvent(window, "beforeunload", async (event) => {
      this.log("[ObsidianObserver] Application quitting detected via beforeunload...");
      try {
        if (this.logger) {
          const { generateBase32Guid: generateBase32Guid2 } = await Promise.resolve().then(() => (init_utils(), utils_exports));
          const eventLog = {
            guid: generateBase32Guid2(),
            timestamp: new Date().toISOString(),
            eventType: "quit",
            filePath: "",
            fileName: "",
            vaultName: this.app.vault.getName(),
            hostname: this.getHostname(),
            metadata: {
              lastModified: new Date().toISOString(),
              quitMethod: "beforeunload"
            }
          };
          await this.logger.logEvent(eventLog);
          await this.logger.flushBuffer();
        }
      } catch (error) {
        console.error("[ObsidianObserver] Error logging quit event:", error);
      }
    });
    this.registerEvent(this.app.workspace.on("quit", async () => {
      this.log("[ObsidianObserver] Workspace quit event detected...");
      try {
        if (this.logger) {
          const { generateBase32Guid: generateBase32Guid2 } = await Promise.resolve().then(() => (init_utils(), utils_exports));
          const eventLog = {
            guid: generateBase32Guid2(),
            timestamp: new Date().toISOString(),
            eventType: "quit",
            filePath: "",
            fileName: "",
            vaultName: this.app.vault.getName(),
            hostname: this.getHostname(),
            metadata: {
              lastModified: new Date().toISOString(),
              quitMethod: "workspace-quit"
            }
          };
          await this.logger.logEvent(eventLog);
          await this.logger.flushBuffer();
        }
      } catch (error) {
        console.error("[ObsidianObserver] Error logging workspace quit event:", error);
      }
    }));
  }
  async onunload() {
    this.log("[ObsidianObserver] Unloading plugin...");
    try {
      if (this.eventHandlers) {
        this.eventHandlers.unregisterEventHandlers();
      }
      if (this.logger) {
        await this.logger.flushBuffer();
      }
      this.log("[ObsidianObserver] Plugin unloaded successfully");
    } catch (error) {
      console.error("[ObsidianObserver] Error unloading plugin:", error);
    }
  }
};
var ObsidianObserverSettingTab = class extends import_obsidian2.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h2", { text: "ObsidianObserver Settings" });
    new import_obsidian2.Setting(containerEl).setName("Plugin Version").setDesc(`Current version: ${this.plugin.manifest.version}`).addText((text) => text.setValue(this.plugin.manifest.version).setDisabled(true));
    this.checkAndDisplayCSSWarning(containerEl);
    new import_obsidian2.Setting(containerEl).setName("Events Folder").setDesc("The base folder where ObsidianObserver will create its structure. Events will be stored in EventsFolder/events and EventSummary.md will be created automatically.").addText((text) => text.setPlaceholder("ObsidianObserver").setValue(this.plugin.settings.eventsFolder).onChange(async (value) => {
      await this.plugin.updateSettings({ eventsFolder: value });
    }));
    new import_obsidian2.Setting(containerEl).setName("Enable Console Logging").setDesc("Log events to the browser console for debugging.").addToggle((toggle) => toggle.setValue(this.plugin.settings.enableConsoleLog).onChange(async (value) => {
      await this.plugin.updateSettings({ enableConsoleLog: value });
    }));
    new import_obsidian2.Setting(containerEl).setName("Reset to Defaults").setDesc("Reset all settings to their default values.").addButton((button) => button.setButtonText("Reset").setWarning().onClick(async () => {
      this.plugin.settings = { ...DEFAULT_SETTINGS };
      await this.plugin.saveSettings();
      this.display();
    }));
  }
  async checkAndDisplayCSSWarning(containerEl) {
    try {
      const cssEnabled = await this.plugin.isCSSEnabled();
      if (!cssEnabled) {
        const warningEl = containerEl.createDiv("setting-item");
        const infoEl = warningEl.createDiv("setting-item-info");
        infoEl.createDiv("setting-item-name").setText("\u26A0\uFE0F CSS Styling Warning");
        warningEl.createDiv("setting-item-description").setText("The table CSS file (obsidianObserverEventsTable.css) is not found in .obsidian/snippets/. Event tables may not display properly. Please ensure the CSS snippet is enabled in Appearance settings.");
        warningEl.style.color = "var(--text-warning)";
        warningEl.style.border = "1px solid var(--text-warning)";
        warningEl.style.padding = "10px";
        warningEl.style.borderRadius = "4px";
        warningEl.style.marginBottom = "10px";
      }
    } catch (error) {
      console.error("[ObsidianObserver] Error checking CSS:", error);
    }
  }
};
